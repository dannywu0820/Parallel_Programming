make DATASIZE=LARGE or MEDIUM or SMALL
make clean
執行檔executable在bin裡
-------------------------------------------------------------
在大部分的情況下我們其實不會直接使用 gcc 命令來編譯，因為如果檔案變多，專案結構複雜，gcc 的命令就會變得很冗長，相對麻煩。
而 make 其實就有點像是編譯器的自動巨集或腳本，我們把編譯的方法和流程寫在 Makefile 裡面，
之後只要輸入 make 命令就可以自動執行一連串的編譯指令，
另外，make 會自動辨識目前程式碼的修改情況來決定哪些文件要重新編譯，節省編譯時間。
以下簡單說明一下 Makefile 最基本的語法的規則
target ... : prerequisites ...
       command
       ..

test: main.c op.c 
 gcc main.c op.c -o test	   
	   
target 通常是我們最後要產生的目標名字，
可能是一個執行檔，或是一個 .o 檔，也有可能代表的是一個動作命令也有可能代表的是一個動作命令
all是一個習慣用法，
Makefile可能有多個編譯流程或步驟，可以選擇只編譯某一項步驟，
但如果是make all的話，他會執行所有有相依性的編譯步驟以完成一個完整的建置
clean 的部分則是執行清除的動作，
清除一些編譯過程的中繼檔案或執行檔，
當然清除的方式和目標也是要自己寫的。

prerequisites 是要生成 target 時所相依的檔案
command 的部分就是生成 target 所需要執行的命令
command 的前面的縮排 (tab) 是規定的，有縮排可讀性也比較高。
-----------------------------------------------------------
test: main.o op.o
 cc main.o op.o -o test
main.o: main.c
 cc -c main.c
op.o: op.c
先從 .c 檔生成 .o，再從 .o 連結成執行檔。
make 在執行的時候會先尋找第一個 target 作為他的最終目標，
這份 Makefile 的第一個 target 就是 test，
根據相依性，他需要 main.o 及 op.o，
於是開始往下尋找如何生成這兩個檔案，而生成方式我們已經寫在後面了。
make 可以自行推導生成方式，從這個思維向上延伸，
實際上連 op.o: op.c 都可以不用寫，
因為看到 op.o 自然也猜得到他的相依檔案會是 op.c ，
所以這個 Makefile 還可以再濃縮成 :
test: main.o op.o
 cc main.o op.o -o test
----------------------------------------------------------
現在我們在資料夾內再創立一個名為 include 的資料夾，
並把 op.h 放進該資料夾內，來模擬標頭檔在其他路徑的情況，
接著把 Makefile 改成以下內容 :
CC = gcc
INC = -I ./include

test: main.o op.o
 $(CC) -o $@ main.o op.o
%.o: %.c
 ${CC} $< ${INC} -c 
一開始使用 = 符號宣告了兩個變數，
第一個是 CC ，用來代表我們所要採用的編譯器形式，
實際上，這個變數同時也是一個內建變數，
如果我們沒有特別指定，他所代表的就是 cc；
第二個變數 INC 則用來表示我們的標頭檔引入路徑，
可以看到前面的 -I 就是 gcc 指定引入路徑的參數，
而後面就是引入的路徑。

$(var) 就是使用變數的方式了，雖然說是變數，
但他的行為其實和 C 語言內的 #define macro 很像，
可以把他想成是純粹文字的替代。
另外，這裡還看到兩個比較特別的變數 $@ 及 $<。
$@ 指的就是該 command 所屬的 target，
所以範例中的 $@ 代表的就是 test ，
而 $< 指的是則第一個相依檔案。
 
%.o 和 %.c 又是什麼？
其實這是一個樣板規則，很像 C++ 的 template，
可以替代成符合規則的文字，
例如，當 make 在嘗試建立 test 時，會需要 main.o，
如果找不到 main.o，make 會開始向下尋找產生 main.o 的方法，
此時的 % 就變成了 main，%.o 就成了 main.o，
而 %.c 就是 main.c。
-----------------------------------------------------------
編譯後一定會產生檔案，可能有執行檔、目的檔等等。
有時我們會希望資料夾可以回到只有 source code 的乾淨狀態，
這時就需要把這些編譯產生物給清除掉，
這個動作我們也可以請 Makefile 來協助處理，
參考以下的 Makefile :
CC = gcc
INC = -I ./include
OBJ = main.o op.o

test: ${OBJ}
 $(CC) -o $@ ${OBJ}
%.o: %.c
 ${CC} $< ${INC} -c 

.PHONY: clean
clean:
 rm -f test ${OBJ}
 
完成以上的 Makefile 後，
在命令列輸入 make clean 便可以執行清理的工作
首先，在實驗四的時候我們發現"main.o op.o"重複寫了兩次，
在這個範例中還會再用到一次，為了避免重複程式碼，
我們把它精煉成變數，同時也方便未來擴充。
接著我們加上clean這個target，負責清除的工作，
你也可以取別的名稱，但clean是一個習慣的用法。
clean 的命令就是 rm 這個移除指令，
由於移除的目標有可能不存在，為了避免 rm 在刪除不存在的檔案時報錯，
我們會加上 -f 參數。
PHONY這個符號的目的是告訴 make，
"clean"不是一個真正的檔案目標，只是一個標記，
不要把他當成檔案來處理，避免有檔案真的叫 clean 時，
make 會在依賴性判斷時判斷錯誤，那就糗了。